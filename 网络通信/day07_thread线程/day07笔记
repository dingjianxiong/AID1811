共享内存：
    通信原理：在内存中开辟一块区域，对多个进程可见，进程可以写入和读取内容，
            但是每次写入内容会覆盖之前的内容
    from multiprocessing import Value,Array
    obj=Value(ctype,obj)
    功能：开辟共享内存空间
    参数：ctype 表示共享内存中存储的数据类型
                'i'-->(int)
                'f'-->(float)
                'c'-->(char(bytes))
        obj  共享内存中的初始化数据
    obj.value  对该属性的修改和使用即对共享内存读写

    obj=Array(ctype,obj)
    功能：开辟共享内存空间
    参数：ctype 表示共享内存中存储的数据类型
        obj  存入一个结构化数据（列表，bytes字串）表示共享内存的出生数据
        或者传入一个整数，表示开辟多大的结构空间
    返回值：共享内存对象
    共享内存读写：可以通过遍历共享内存对象获取每个值，同时支持索引操作
                obj[1] 表示获取第二项
            如果存入字节串，可以使用obj.value直接打印
    
总结：
            　管道    　　      消息队列    　　　　共享内存
    开辟空间　　内存    　　    　内存          　　　内存
    读写方式  两端读写　　　    　先进先出　　　　　　　覆盖之前内容
    效率      一般              一般           　　较高
    特定     多用于父子进程  　　　很多第三方队列　　　　注意同步互斥（）
        
信号量（信号灯）
    原理：给定一个数量。多个进程均可见，多个进程可以操作信号量的增加和消耗，
        达到协调工作的目的
    from multiprocessing import Semaphore
    sem=Semaphore(num)
    功能：创建信号量对象
    参数：信号量初始值
    返回值：信号量对象
    sem.acquire()　　　将信号量减一，如果信号量为０．则阻塞
    sem.release()  　　将信号量加１
    sem.get_value() 　获取信号量数量


线程（Thread)
    什么是线程：
        １、线程也是多任务编程的方法
        ２、也可以利用计算机多核资源
        ３、线程是轻量级的进程
        ４、线程是系统分别内核的最小工作单元
    线程特征
        １、一个进程可以包含多个线程
        ２、线程是一个运行过程，消耗计算机资源
        ３、一个进程中可以包含多个线程，多个线程共享进程的系统资源
        ４、多个线程的执行互不影响
        ５、线程的创建和消耗，消耗资源较小
        ６、每个线程也有自己的特征，ID指令集等
    threading 模块
        from threading import Thread
        t = Thread()
        功能：创建线程
        参数：target  绑定线程函数
                args 元组　　给线程传参
                kwargs　字典　　给线程函数键值传参
                name　线程名称　　默认　Thread-1
        t.start()  启动线程，自动运行target 函数
        t.join([timeout]) 回收线程
                            （分支线程阻塞时等待执行完，然后回收线程，再执行主线程）
    线程对象属性
    t.name()  线程名称
    t.setName()  设置线程名称
    t.getName()  获取线程名称

    t.is_alive()  线程状态（生命周期是否结束？）
    currentThread()  在线程函数中获取当前线程对象
    t.daemon  默认fales,表示主线程退出不影响分支线程执行
                设置为true,则主线程退出，分支线程也退出
    t.setDaemon()　　设置daemon值
    t.isDaemon()    查看daemon值
        *在start前设置daemon属性，通常不会和join()一同使用

创建自己的线程类
    步骤：
        １、继承Thread
        ２、编写__init__添加属性，加载父类init
        ３、重写run方法
    使用：
        使用自己的类创建线程对象，调用start启动线程，则自动执行run方法

线程通信
    通信方法：使用进程空间中全局变量通信
    注意事项：共享资源的争夺，往往需要同步互斥机制

线程的同步互斥
    共享资源（临界资源）：多个进程资源或者线程都可以操作的资源被称为共享资源
    临界区：指一段代码，对临界资源操作的代码段叫临界区
    同步：同步是一种合作关系，为完成任务，多进程或多线程之间形成一种协调，
        按照有必要的步骤有序执行操作临界资源
    互斥：互斥是一种制约关系，当一个进程或线程抢占到临界资源会加锁处理，
        另一个进程或线程就无法操作，直到解锁后才能操作
同步互斥方法（主要为互斥方法）：
    线程Evend
        from threading import Evend
        e=Evend()
        功能：创建Evend对象
        
        e.wait([timeout])
        功能：阻塞函数，等待e被set
        参数：超时时间

        e.set()
        功能：设置e的状态为set状态（结束e.wait()阻塞）

        e.clear()
        功能：将e变回未设置的状态

        e.is_set()
        功能：判断e的当前状态，被设置返回true，未被设置返回false
    线程锁　Lock
        from threading import Lock
        lock=Lock() 创建锁对象

        lock.acpuire() 上锁，　如果重复上锁，就会阻塞
        lock.release() 解锁

        with lock: ---> 上锁
                临界区代码
                    －－> with代码块结束自动解锁
python线程的GIL问题（全局解释器锁）
    GIL：由于python解释器加入了全局解释器锁，导致python解释在同一个时刻只能
        解锁一个线程，所以大大降低了python多线程的执行效率，
    后果：python线程一般会用在大量io阻塞的程序，或者高延迟的程序
        例如：网络编程；因为python线程遇到阻塞时，会主动让出解释器。
    GIL解决建议：
        *尽量使用进程完成并发
        *修改c解释器或不使用c解释器
        *可以使用多种组合并发（进程＋多路复用）
作业：
    １、总结进程线程各自的优点，区别和编程特点
    ２、复习socket套接字使用
    ３、聊天室代码思路