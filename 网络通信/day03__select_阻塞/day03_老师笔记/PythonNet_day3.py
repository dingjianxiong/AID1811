课程：PythonNet
进度：day3

--------- 主要内容 ----------
1. I/O模型
2. I/O多路复用
   select, poll, epoll
------------------------------

上次内容回顾
1. 网络缓冲区
   创建socket对象的时候，每个对象都会创建
   输入、输出缓冲区，在调用recv或send的时候
   写入缓冲区或从缓冲区接收，从而提高读写效率
   协调收发速度

2. 粘包
   - 在TCP套接字中，上一个包的包尾接着下一个包
   的包头的情况
   - 处理方式
     增加包头、包尾标识
     在包头部分增加数据包长度字段

3. UDP套接字
	- UDP：无连接、不可靠传输、传输效率高
	       适合于数据量小、可靠性要求不高的情况
	- 工作流程：
	  服务器端：创建socket->绑定->收发数据->关闭
	  客户端：创建socket->收发数据->关闭
	- 主要函数
	  scoket,bind,sendto,recvfrom

4. TCP套接字和UDP套接字的比较
	TCP：面向连接，字节流，粘包，可靠传输
	     listen/accept，客户端需要连接
		 send,recv
	UDP: 不需要连接，数据报，不会粘包，不可靠传输
	     服务器不需要listen/accept
		 客户端不需要连接
		 sendto,recvfrom

5. 广播
   - 广播：一点发送，网段内所有的节点接收
   - 发送时候使用广播地址
     192.168.1.3
	 网络ID：前24bits
	 主机ID：后面8bits
	 0~255编号


今天的内容
1. I/O模型
  1) 什么是I/O: 输入，输出
    - 输入：将IO设备上的数据读入内存
	- 输出：将内存中的数据写到IO设备

	I/O操作：涉及到输入输出的操作
	- 外设操作：打印机，显示器，键盘，鼠标
	- 外部存储设备操作：磁盘文件读写
	- 网络通信：从网络收发数据

  2)阻塞IO
	- 阻塞：应用程序发出某个函数调用后
	        等待操作系统内核返回结果
			才能执行后面的代码
			这个过程称之为阻塞
    - 阻塞产生的原因
		- 程序等待某种条件、状态
		- 处理IO时候，需要一定时间

  3)非阻塞IO
	- 非阻塞：当程序发出IO操作时，如果内核
	          中数据没准备好(需要的条件没达成)
			  不会阻塞，而是返回一个error
	- 特点
		防止程序一直阻塞在某个IO上
	
	超时：某些操作在等待一定时间后
	     如果没有结果程序主动放弃等待
  
2. IO多路复用
  1）什么是IO多路复用
    - 一个进程（程序）监视多个IO设备
	  当这些IO上出现了可读写事件
	  （这种情况下，称之为IO就绪）
	  程序对IO事件进行处理（读、写、异常）
	  处理完成后，等待下一次IO事件
	  多路复用能够避免一个IO阻塞其它IO无法处理的
	  情况
    - IO多路复用也属于阻塞IO

  2）IO多路复用的实现方式
	- select: windows, linux/Unix
	- poll: linux/Unix
	- epoll: linux/Unix

  3）select
	- 功能：监控（关注）多个IO，
	        如果某个IO处于就绪状态
			则立即返回、通知应用程序
	- 格式：
	  rs,ws,xs=select(rlist,wlist,xlist[,timeout])

	  参数：
	    rlist: 列表类型，等待读事件IO
		wlist: 列表类型，等待写事件IO
		xlist: 列表类型，存放发生异常需要处理IO
		timeout:超时事件，可选
	  返回值：
		rs:列表,rlist中准备就绪的IO(可进行读操作)
		ws:列表,wlist中准备就绪的IO(可进行写操作)
		xs:列条,xlist中准备就绪的IO(需要异常处理)
	
	- 注意事项：
		wlist中有IO事件，select会立即返回ws
		在处理IO事件过程中，避免一个客户端
		   长时间占用服务器或死循环的情况

	4）二进制位运算
		&  和运算      同时为真结果为真
		   1 & 1 = 1
		   1 & 0 = 0
		   0 & 1 = 0
		   0 & 0 = 0
		|  或运算      至少一个为真结果为真
		   1 | 1 = 1
		   1 | 0 = 1
		   0 | 0 = 0
		^  异或运算    必须一个为真，一个为假
		   1 ^ 0 = 1
		   0 ^ 1 = 1
		   0 ^ 0 = 0
		   1 ^ 1 = 0
		<< 左移位运算
		>> 右移位运算

		例如：
	    1100  ==> 12 
		0011  ==> 3
		用相同位置的二进制数做逻辑运算，然后
		   将得到的结果转换成10进制
		12 & 3 ==> 0
			1100
			0011 
            0000 ==> 0
		12 | 3 ==> 15
			1100
			0011
            1111 ==> 15
		12 ^ 3 ==> 15
			1100
			0011
			1111 ==> 15

		12<<1 (将12做左移位运算)
		1100 ==> 所有的二进制位向左移动1位
		         右边空出一位填0
        11000 ==> 24

		12>>1 (将12右移一位)
		1100 ==> 所有的二进制位右移一位，去掉低位
		110 ==> 6

		用二进制位表示状态：每一个二进制位表示
		    一种状态（例如socket的读是否就绪）
		例如：使用8bits数字，可以保持8种状态
		00000011
        
		如果要取出右边第一位，方法用00000001按位
		  做和运算
		00000001
		00000001

	5）poll实现IO多路复用
		- poll和select原理一样，监控多个IO的
		  状态，并返回给应用程序
		- poll监控的文件描述符数量没有限制
		- 事件：
			POLLIN	表示IO的读事件
			POLLOUT	表示IO的写事件
			POLLERR	表示IO的异常事件
			POLLHUP	表示IO被断开
			POLLNVAL 无效请求
		- 主要函数
		register: 将IO加入到关注列表
			格式：register(fd, [eventmask])
			参数：fd   IO的文件描述符
				  eventmask 监测/关注的事件
			例如：register(fd, POLLIN)
				  表示关注fd的读事件

				  register(fd, POLLIN|POLLOUT)
				  表示关注fd读写事件

		unregister(fd):取消关注fd事件

		poll：阻塞，并等待关注IO列表的事件发生
		    格式：events = p.poll()
			说明：p为poll对象
			返回值： events  列表  
			        元素都是一个元组
				(fileno1, event1) 文件描述符，就绪事件
				(fileno2, event2)
				(fileno3, event3)
				……

