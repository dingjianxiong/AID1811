进程创建对象注意：
    如果父进程先创建对象，再创建子进程，则子进程从父进程获取偏移量，
    此时，父进程在对象操作上有一定的影响
        *套接字会监听一个端口，文件上会有一个偏移量
    如果父进程先创建子进程，父子进程中各自创建的对象没有任何和关联

multiprocessing(多进程)模块创建进程
    １、将需要执行的进程事件封装成函数
    ２、使用模块的process类生成进程对象，并关联函数
    ３、可以通过对象的属性设置进程信息
    ４、启动进程，执行绑定函数
    ５、回收进程

process()
功能：创建进程对象
参数：target　必选　绑定的目标函数
        name 给进程起名字，process-1,process-2...
        args 元组，给target 目标函数传参（位置传参）
        kwargs 字典，给target 目标函数传参　键值传参
p.start()
功能：启动进程
*target 绑定的函数作为进程函数执行，进程被创建

p.join([timeout])
功能：阻塞等待回收进程
参数：超时进程

注意：
    *　使用multiprocessing创建进程，同样子进程复制父进程的全部代码段，
        父子进程执行互不影响，各自有各自的运行空间，子进程只执行函数部分
    join会回收子进程，否则会产生僵尸进程
    *　multiprocessing中父进程往往只用来创建和管理子进程，具体事件由子进程完成
进程对象属性
    p.name 进程名称
    p.pid  进程pid号
    p.is_alive() 查看进程的状态（是否在生命周期内）
    p.daemon 默认为falese 表示主进程退出不会影响子进程执行
            如果设置为true　表示主进程退出时，子进程也会退出
            * 必须子啊start之前使用
自定义进程类
    步骤：
        １、继承于process类
        ２、编写自己的__init__添加自定义属性
            使用super重新加载父类__init__
        ３、重写run方法
    使用：
        １、使用自定义的类创建进程对象
        ２、使用该对象调用start启动进程，此时会自动执行run函数
        ３、使用该对象调用join()回收该进程
进程池
    产生的原因：如果有大量任务需要多进程完成，则可能需要频繁的创建删除进程，
                给计算机带来的压力较大，进程池正是为了解决此问题
    原理：创建进程池，放入一定量的进程，用来处理事件，事件处理完毕后，进程不退出
            而是继续等待处理其他事件，直到所有事件结束再统一销毁进程池
            增加进程的重复利用，降低资源消耗
    步骤：
        １、创建进程池，添加适当的进程
        ２、将要完成的事件放入进程池等待队列
        ３、不断取事件交由进程中分进程完成，直到所有事件处理完毕
        ４、关闭进程池，回收进程
    from multiprocessing import pool
    pool=pool(process)
    功能：创建进程池对象
    参数：进程池中进程数量，默认根据系统自动判断

    pool.apply_async(func,args,kwds)
    功能：使用进程池中的进程执行函数事件
    参数：   func 要执行的函数
            args 元组　给func传参
            kwds 字典　给 func键值传参
    返回值：函数事件对象　通过get()方法可以获取func函数的返回值（return）

    pool.cloce()
    功能：关闭进程池，不能再添加新的事件函数，但会等待进程池里的进程执行完

    pool.join()
    功能：回收进程池
*进程池事件func一定在进程池创建之前声明

    pool.apply(func,args,kwds)
    功能：使用进程池中的进程执行函数事件
    参数：   func 要执行的函数
            args 元组　给func传参
            kwds 字典　给 func键值传参
    返回值：函数事件对象　通过get()方法可以获取func函数的返回值（return）

    pool.cloce()
    功能：关闭进程池，不能再添加新的事件函数，但会等待进程池里的进程执行完

    pool.join()
    功能：回收进程池
*进程池事件func一定在进程池创建之前声明

pool.map(func,iter)
功能：将要做的事件加入进程池执行
参数：　　func 要执行的函数
    　　　iter 迭代对象
返回值：　函数返回值列表

进程间通信（IPC）
    原因：进程空间相对独立，资源无法相互获取，此时在不同进程间需要专门的方法进行通信
    进程间通信方法（第三方介子）：管道    消息队列    共享内存    
                            　信号    信号量  套接字

管道通信（pipe）
    通信原理：在内存中开辟管道空间，生成管道操作对象，多个进程使用同一个管道对象
            读写即可实现通信
    from multiprocessing import Pipe
    fd1,fd2=Pipe(duplex=True)
    功能：创建管道
    参数：默认表示双向管道，如果设置为false则表示单向管道
    返回值：表示管道的两端读写对象
            如果是双向管道均可读写
            如果是单向管道则fd1只读，fd2只写
    fd.recv()
    功能：从管道读取内容，无内容则阻塞
    返回值：读取到的内容

    fd.send(data))
    功能：向管道写入内容
    参数：要写入的内容

消息队列
    队列：存储模型，线性的，先进先出原则
    原理：在内存中建立队列模型，进程通过队列对象将消息存入队列，或从队列取出消息，
            完成进程间通信
    from multiprocessing import Queue
    q=Queue(maxsize)
    功能：创建队列对象
    参数：表示队列中过多存放消息个数
    返回值：队列对象

    q.put(data,[block,timeout])
    功能：向队列存入消息
    参数：data 要存入的内容
        block 默认队列满时会阻塞，设置为false则为非阻塞
        timeout 超时时间
    
    q.get([block,timeout])
    功能：从队列取出消息
    参数：block 默认队列为空时会阻塞，设置为false则为非阻塞
            timeout 超时时间
    q.full()判断队列是否满了
    q.empty()判断队列是否为空
            (当消息队列为空时，执行q.put()，然后执行q.empty()时，会判断为空，
            因为消息还未放入内存中就去查看并判断了，但可以取出消息
    q.qsize()获取队列中消息个数
    q.close()关闭队列

作业：
    １、multiprocessing创建进程方法整理，与fork比较
    ２、复习http协议